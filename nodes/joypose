#!/usr/bin/env python
import ode
import numpy as np

import roslib; roslib.load_manifest('flyvr')
import rospy

from geometry_msgs.msg import Pose
from sensor_msgs.msg import Joy
import tf.transformations

FPS=100.0

def odeR2quat(Rmat,eps=1e-15):
    Rmat = np.array(Rmat); Rmat.shape = (3,3)
    R = np.eye(4); R[:3,:3]=Rmat
    quat = tf.transformations.quaternion_from_matrix(R)
    return quat

class JoyPose:
    def __init__(self):
        rospy.init_node('joypose')
        self.pub = rospy.Publisher('pose', Pose)
        self.last_time = rospy.get_time()
        self.pitch, self.yaw, self.roll, self.thrust = [0,0,0,0]
        self.world = ode.World()
        self.reset()

        rospy.Subscriber("joy", Joy, self.on_joy)
        rospy.Timer(rospy.Duration(1.0/FPS), self.on_timer)

    def reset(self):
        self.body = body = ode.Body(self.world)
        M = ode.Mass()
        M.setSphere(2500.0, 0.05)
        M.mass = 1.0
        body.setMass(M)
        body.setPosition( (0,0,0) )

    def on_joy(self,msg):
        self.roll, self.pitch, _, self.thrust = msg.axes[:4]
        self.yaw = 0
        if len(msg.buttons) < 16:
            return
        # button assignments are for PS3 dual shock joystick
        if msg.buttons[10]: # L1
            self.yaw += 1
        if msg.buttons[11]: # R1
            self.yaw -= 1
        if msg.buttons[15]: # pink square
            self.reset()

    def gain_func(self, in_val):
        return 1e-2*in_val**3

    def on_timer(self,_):
        now = rospy.get_time()
        dt = now-self.last_time
        if dt<=0:
            return
        self.last_time = now

        # update dynamic model

        # active turning term
        torques = (self.gain_func(-self.roll),
                   self.gain_func(self.pitch),
                   self.gain_func(self.yaw) )
        self.body.addRelTorque( torques )

        # rotational damping term
        u,v,w = self.body.getAngularVel()
        rotation_damping_gain = -1e-2

        t2 = (rotation_damping_gain*u,
              rotation_damping_gain*v,
              rotation_damping_gain*w)
        self.body.addTorque( t2 )
        #self.body.addRelTorque( t2 )

        # thrust
        self.body.addRelForce( (  (self.thrust+1.0)**3,0.0,0.0) )
        # drag
        x,y,z = self.body.getLinearVel()
        g = -10.0
        self.body.addForce( (g*x, g*y, g*z) )

        # integrate
        self.world.step(dt)

        msg = Pose()
        quat = odeR2quat(self.body.getRotation())
        for i in range(4):
            setattr(msg.orientation,'xyzw'[i], quat[i])
        x,y,z=self.body.getPosition()
        msg.position.x=x
        msg.position.y=y
        msg.position.z=z

        self.pub.publish(msg)

if __name__=='__main__':
    jp = JoyPose()
    rospy.spin()
